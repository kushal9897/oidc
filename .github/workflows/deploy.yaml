name: Deploy Infrastructure (PR)

on:
  pull_request:
    branches: [ main ]
    paths:
      - 'namespaces/**'  

# Vault OIDC + repo read
permissions:
  id-token: write
  contents: read
  pull-requests: write

env:
  VAULT_ADDR: ${{ secrets.VAULT_ADDR }}
  TF_VERSION: "1.6.0"
  VAULT_ROLE: github-actions       # store in secrets or env as you prefer
  VAULT_NAMESPACE: admin   

jobs:
  detect-changes:
    name: Detect Changed Namespaces
    runs-on: ubuntu-latest
    outputs:
      namespaces: ${{ steps.detect.outputs.namespaces }}
      has-changes: ${{ steps.detect.outputs.has-changes }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for reliable diff

      - name: Detect changed namespaces
        id: detect
        shell: bash
        run: |
          set -euo pipefail

          BASE="${{ github.event.pull_request.base.sha }}"
          HEAD="${{ github.event.pull_request.head.sha }}"
          echo "BASE=$BASE"
          echo "HEAD=$HEAD"

          # Ensure we have both commits locally
          echo "Fetching base and head commits..."
          git fetch --no-tags --prune --depth=1 origin "$BASE" || {
            echo "Failed to fetch base commit, falling back to merge-base"
            git fetch --no-tags --prune origin main
            BASE=$(git merge-base origin/main HEAD)
            echo "Using merge-base: $BASE"
          }

          # Get changed files under namespaces/ directory
          echo "Detecting changed files..."
          CHANGED_FILES=$(git diff --name-only "$BASE"..."$HEAD" -- 'namespaces/' 2>/dev/null || true)
          
          if [[ -z "$CHANGED_FILES" ]]; then
            echo "No changes detected under namespaces/"
            echo "namespaces=[]" >> "$GITHUB_OUTPUT"
            echo "has-changes=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "Changed files under namespaces/:"
          echo "$CHANGED_FILES"

          # Extract namespace directories (2nd path segment) and deduplicate
          # Only include valid namespaces (must have at least one .tf file)
          VALID_NAMESPACES=()
          while IFS= read -r file; do
            if [[ "$file" =~ ^namespaces/([^/]+)/ ]]; then
              namespace="${BASH_REMATCH[1]}"
              # Check if this namespace has .tf files
              if ls "namespaces/$namespace"/*.tf >/dev/null 2>&1; then
                VALID_NAMESPACES+=("$namespace")
              else
                echo "Warning: $namespace doesn't contain .tf files, skipping"
              fi
            fi
          done <<< "$CHANGED_FILES"

          # Remove duplicates and sort
          if (( ${#VALID_NAMESPACES[@]} == 0 )); then
            echo "No valid namespace changes detected"
            echo "namespaces=[]" >> "$GITHUB_OUTPUT"
            echo "has-changes=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Create unique sorted array
          mapfile -t UNIQUE_NS < <(printf '%s\n' "${VALID_NAMESPACES[@]}" | sort -u)

          # Generate JSON array
          JSON=$(printf '%s\n' "${UNIQUE_NS[@]}" | jq -R -s -c 'split("\n")[:-1]')
          echo "namespaces=$JSON" >> "$GITHUB_OUTPUT"
          echo "has-changes=true" >> "$GITHUB_OUTPUT"
          echo "Detected valid namespaces: $JSON"

  plan:
    name: Plan (${{ matrix.namespace }})
    needs: detect-changes
    if: needs.detect-changes.outputs.has-changes == 'true'
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false  # Continue with other namespaces even if one fails
      matrix:
        namespace: ${{ fromJson(needs.detect-changes.outputs.namespaces) }}
    defaults:
      run:
        working-directory: namespaces/${{ matrix.namespace }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false  # Better for CI/CD pipelines

      - name: Cache Terraform providers
        uses: actions/cache@v4
        with:
          path: ~/.terraform.d/plugin-cache
          key: terraform-${{ runner.os }}-${{ hashFiles('namespaces/${{ matrix.namespace }}/.terraform.lock.hcl') }}
          restore-keys: |
            terraform-${{ runner.os }}-

      - name: Get Vault Token via GitHub OIDC
  id: vault-auth
  if: github.event.pull_request.head.repo.full_name == github.repository  # skip forks (no OIDC)
  shell: bash
  run: |
    set -euo pipefail

    # Sanity check: OIDC context exists
    if [[ -z "${ACTIONS_ID_TOKEN_REQUEST_URL:-}" || -z "${ACTIONS_ID_TOKEN_REQUEST_TOKEN:-}" ]]; then
      echo "OIDC context not available (likely a forked PR or missing permissions)."
      exit 0
    fi

    # Your role allows either "vault" or "https://github.com/kushal9897" as audience.
    # Try "vault" first (simplest), then fall back to the GitHub URL if needed.
    get_jwt() {
      local aud="$1"
      curl -sSL \
        -H "Authorization: bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN" \
        "$ACTIONS_ID_TOKEN_REQUEST_URL&audience=${aud}" | jq -r '.value'
    }

    echo "Requesting GitHub OIDC token (audience=vault)"
    JWT_TOKEN="$(get_jwt "vault")"
    if [[ -z "$JWT_TOKEN" || "$JWT_TOKEN" == "null" ]]; then
      echo "Retrying with audience=https://github.com/kushal9897"
      JWT_TOKEN="$(get_jwt "https://github.com/kushal9897")"
    fi

    if [[ -z "$JWT_TOKEN" || "$JWT_TOKEN" == "null" ]]; then
      echo "Failed to obtain OIDC token"
      exit 1
    fi

    # Optional: Verify claims match your role before calling Vault
    # Your role bound_subject: repo:kushal9897/oidc:ref:refs/heads/*
    IFS='.' read -r _ payload _ <<< "$JWT_TOKEN" || true
    if decoded=$(echo "$payload" | tr '_-' '/+' | base64 -d 2>/dev/null); then
      sub=$(echo "$decoded" | jq -r '.sub // empty')
      aud=$(echo "$decoded" | jq -cr '.aud // empty')
      echo "OIDC sub: $sub"
      echo "OIDC aud: $aud"
      case "$sub" in
        repo:kushal9897/oidc:ref:refs/heads/*) ;;  # OK
        *)
          echo "JWT 'sub' does not match bound_subject (repo:kushal9897/oidc:ref:refs/heads/*)"; 
          echo "Ref/branch or repository may not match role constraints."
          exit 1
          ;;
      esac
    else
      echo "Warning: could not decode JWT claims for local validation (continuing)."
    fi

    : "${VAULT_ADDR:?VAULT_ADDR is required}"
    : "${VAULT_ROLE:?VAULT_ROLE is required}"
    VAULT_NAMESPACE="${VAULT_NAMESPACE:-admin}"

    echo "Authenticating with Vault (role=${VAULT_ROLE}, ns=${VAULT_NAMESPACE})"
    RESPONSE="$(curl -sSL --request POST \
      --header "X-Vault-Namespace: ${VAULT_NAMESPACE}" \
      --header "Content-Type: application/json" \
      --data "{\"jwt\": \"${JWT_TOKEN}\", \"role\": \"${VAULT_ROLE}\"}" \
      "${VAULT_ADDR}/v1/auth/jwt/login")"

    VAULT_TOKEN="$(echo "$RESPONSE" | jq -r '.auth.client_token')"
    if [[ -z "$VAULT_TOKEN" || "$VAULT_TOKEN" == "null" ]]; then
      echo "Vault authentication failed"
      echo "$RESPONSE"
      exit 1
    fi

    echo "Vault authentication successful"
    echo "::add-mask::$VAULT_TOKEN"
    {
      echo "VAULT_TOKEN=$VAULT_TOKEN"
      echo "VAULT_ADDR=$VAULT_ADDR"
      echo "VAULT_NAMESPACE=$VAULT_NAMESPACE"
    } >> "$GITHUB_ENV"
      - name: Validate Terraform files
        run: |
          echo "Checking Terraform formatting..."
          if ! terraform fmt -check -diff; then
            echo " Terraform files are not properly formatted"
            echo "Run 'terraform fmt -recursive' to fix formatting issues"
            exit 1
          fi
          echo "Terraform formatting is correct"

      - name: Initialize Terraform
        run: |
          echo "Initializing Terraform..."
          terraform init -input=false
          echo "Terraform initialized successfully"

      - name: Validate Terraform configuration
        run: |
          echo "Validating Terraform configuration..."
          terraform validate
          echo "Terraform configuration is valid"

      - name: Generate Terraform plan
        id: plan
        run: |
          echo "Generating Terraform plan..."
          terraform plan -input=false -no-color -detailed-exitcode > plan.out 2>&1 || EXIT_CODE=$?
          
          # Handle Terraform plan exit codes:
          # 0 = No changes
          # 1 = Error
          # 2 = Changes present
          case ${EXIT_CODE:-0} in
            0)
              echo "plan-result=no-changes" >> "$GITHUB_OUTPUT"
              echo " No infrastructure changes needed"
              ;;
            1)
              echo "plan-result=error" >> "$GITHUB_OUTPUT"
              echo "Terraform plan failed"
              cat plan.out
              exit 1
              ;;
            2)
              echo "plan-result=changes" >> "$GITHUB_OUTPUT"
              echo "Infrastructure changes detected"
              ;;
          esac

      - name: Comment PR with plan results
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const namespace = '${{ matrix.namespace }}';
            const planResult = '${{ steps.plan.outputs.plan-result }}';
            
            let comment = `## Terraform Plan Results for \`${namespace}\`\n\n`;
            
            if (planResult === 'no-changes') {

              comment += ' No infrastructure changes needed\n';
            } else if (planResult === 'error') {
              comment += ' Terraform plan failed\n';
            } else if (planResult === 'changes') {
              comment += ' Infrastructure changes detected\n\n';
              
              try {
                const plan = fs.readFileSync('namespaces/' + namespace + '/plan.out', 'utf8');
                comment += '<details>\n<summary>Click to view plan details</summary>\n\n```hcl\n';
                comment += plan.slice(0, 20000); // Limit size to avoid GitHub comment limits
                if (plan.length > 20000) {
                  comment += '\n... (truncated)\n';
                }
                comment += '\n```\n</details>\n';
              } catch (error) {
                comment += 'Could not read plan output file.\n';
              }
            }
            
            // Find existing comment for this namespace
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            
            const botComment = comments.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes(`Terraform Plan Results for \`${namespace}\``)
            );
            
            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: comment
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: comment
              });
            }

  summary:
    name: Plan Summary
    needs: [detect-changes, plan]
    if: always() && needs.detect-changes.outputs.has-changes == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Generate summary
        uses: actions/github-script@v7
        with:
          script: |
            const namespaces = ${{ needs.detect-changes.outputs.namespaces }};
            const planJobs = Object.values(context.payload.workflow_run?.jobs || {})
              .filter(job => job.name.startsWith('Plan ('));
            
            let summary = '##  Terraform Plan Summary\n\n';
            summary += `**Namespaces processed:** ${namespaces.length}\n\n`;
            
            if (namespaces.length === 0) {
              summary += ' No namespace changes detected\n';
            } else {
              summary += '| Namespace | Status |\n';
              summary += '|-----------|--------|\n';
              
              for (const namespace of namespaces) {
                // This is a simplified status check - in a real scenario you'd check job results
                summary += `| \`${namespace}\` | Processing |\n`;
              }
            }
            
            console.log(summary);

      - name: Terraform Apply
        run: terraform apply -auto-approve
